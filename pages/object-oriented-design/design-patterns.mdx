# Design Patterns

### What are Design Patterns?

**Design Patterns** are solutions to commonly-occurring problems in software design. 

Design patterns help developers by providing a common language and set of best practices for solving common design problems. 

They were originally introduced by the "Gang of Four" (Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) in 
their book, _"Design Patterns: Elements of Reusable Object-Oriented Software."_


### Disadvantages of Design Patterns

1. **Overengineering**: Design patterns can sometimes lead to overengineering, where developers use complex patterns to solve simple problems.
2. **Complexity**: Design patterns can bring unnecessary complexity, if applied at wrong places.
3. **Learning Curve**: Developers who are not familiar with them might end up getting confused and spend more time on code changes.

### Types of Design Patterns

There are three main types of design patterns: **Creational**, **Structural** and **Behavioral**.

**Creational Patterns** deal with _object creation mechanisms_ for specific situation without revealing the creation method. Creational design patterns are:
- Singleton
- Factory Method
- Abstract Factory
- Builder
- Prototype

**Structural Patterns** deal with _object and classes composition_ and relationships between different objects. Structural design patterns are:
- Adapter
- Bridge
- Composite
- Decorator
- Facade
- Flyweight
- Proxy

**Behavioral Patterns** deal with _communication_ between different objects. Behavioral design patterns are:
- Chain of Responsibility
- Command
- Interpreter
- Iterator
- Mediator
- Memento
- Observer
- State
- Strategy
- Template Method
- Visitor

### Examples of Design Patterns

#### Creational Patterns

1. **Singleton**: Ensures that a class has only one instance and provides a global point of access to it.

```typescript copy
class Singleton {
    private static instance: Singleton;

    private constructor() {}

    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
}

const singleton1 = Singleton.getInstance();
const singleton2 = Singleton.getInstance();

console.log(singleton1 === singleton2); // true
```

2. **Factory Method**: Defines a method for creating objects without specifying their concrete classes. This method is used
instead of using a direct constructor call (`new` operator).

```typescript copy
interface Animal {
    speak(): void;
}

class Dog implements Animal {
    public speak(): void {
        console.log("The dog barks.");
    }
}

class Cat implements Animal {
    public speak(): void {
        console.log("The cat meows.");
    }
}

class AnimalFactory {
    public getAnimal(type: string): Animal {
        switch (type) {
            case "dog":
                return new Dog();
            case "cat":
                return new Cat();
            default:
                throw new Error("Invalid animal type.");
        }
    }
}

const animalFactory = new AnimalFactory();
const dog = animalFactory.getAnimal("dog");
const cat = animalFactory.getAnimal("cat");

dog.speak(); // Outputs: The dog barks.
cat.speak(); // Outputs: The cat meows.
```

3. **Abstract Factory**: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

```typescript copy
interface Button {
  paint(): void;
}

interface Checkbox {
  paint(): void;
}

class WinButton implements Button {
  public paint(): void {
    console.log('Windows button is painted.');
  }
}

class WinCheckbox implements Checkbox {
  public paint(): void {
    console.log('Windows checkbox is painted.');
  }
}

class MacButton implements Button {
  public paint(): void {
    console.log('Mac button is painted.');
  }
}

class MacCheckbox implements Checkbox {
  public paint(): void {
    console.log('Mac checkbox is painted.');
  }
}

interface GUIFactory {
  createButton(): Button;
  createCheckbox(): Checkbox;
}

class WinFactory implements GUIFactory {
  public createButton(): Button {
    return new WinButton();
  }

  public createCheckbox(): Checkbox {
    return new WinCheckbox();
  }
}

class MacFactory implements GUIFactory {
  public createButton(): Button {
    return new MacButton();
  }

  public createCheckbox(): Checkbox {
    return new MacCheckbox();
  }
}

const config = 'WIN'; // or "MAC"
let factory: GUIFactory;

if (config === 'WIN') {
  factory = new WinFactory();
} else if (config === 'MAC') {
  factory = new MacFactory();
} else {
  throw new Error('Unknown OS.');
}

const button = factory.createButton();
const checkbox = factory.createCheckbox();

button.paint(); // Outputs: Windows button is painted.
checkbox.paint(); // Outputs: Windows checkbox is painted.
```

4. **Builder**: Constructs complex objects step by step. It allows constructing different representations of an object 
using the same construction functions.

```typescript copy
class Task {
  name: string;
  description: string;
  priority: 'low' | 'medium' | 'high';
  dueDate: Date;
}

interface ITaskBuilder {
  setName(name: string): void;
  setDescription(text: string): void;
  setPriority(priority: 'low' | 'medium' | 'high'): void;
  setDueDate(date: Date): void;
}

class TaskBuilder implements ITaskBuilder {
  private task: Task;

  constructor() {
    this.task = new Task();
  }

  public reset(): void {
    this.task = new Task();
  }

  public setDescription(text: string): TaskBuilder {
    this.task.description = text;
    return this;
  }

  public setPriority(priority: 'low' | 'medium' | 'high'): TaskBuilder {
    this.task.priority = priority;
    return this;
  }

  public setDueDate(date: Date): TaskBuilder {
    this.task.dueDate = date;
    return this;
  }

  public setName(name: string): TaskBuilder {
    this.task.name = name;
    return this;
  }

  public build(): Task {
    const result = this.task;
    this.reset();
    return result;
  }
}

function buildSimpleTask(): Task {
  const builder = new TaskBuilder();
  builder
    .setName('Finish book')
    .setPriority('low');
  return builder.build();
}

function buildUrgentMeetingTask(): Task {
  const builder = new TaskBuilder();
  builder
    .setName('Meet friend')
    .setDescription('Meet friend at the train station')
    .setPriority('high')
    .setDueDate(new Date('2024-12-31'));
  return builder.build();
}
```

5. **Prototype**: Creates new objects by copying an existing object, known as the prototype. Usually involves creating a `clone` method,
which returns a copy of object.

```typescript copy
class Sheep {
  name: string;
  weight: number;

  constructor(name: string, weight: number) {
    this.name = name;
    this.weight = weight;
  }

  clone(): Sheep {
    return new Sheep(this.name, this.weight);
  }
}

const originalSheep = new Sheep('Jolly', 20);
const clonedSheep = originalSheep.clone();

console.log(clonedSheep.name); // Output: Jolly
console.log(clonedSheep.weight); // Output: 20
```

#### Structural Patterns

1. **Adapter**: Allows objects with incompatible interfaces to collaborate.

```typescript copy
interface MicroUsbPort { // Target interface
  connect(): string;
}

class UsbCable { // Adaptee
  public specificConnect(): string {
    return 'UsbCable';
  }
}

class MicroUsbAdapter implements MicroUsbPort { // Adapter
  private adaptee: UsbCable;

  constructor(adaptee: UsbCable) { 
    this.adaptee = adaptee;
  }

  public connect(): string {
    return `MicroUsbAdapter connects usb port with ${this.adaptee.specificConnect()}`;
  }
}

const adaptee = new UsbCable();
const adapter = new MicroUsbAdapter(adaptee);

adapter.connect(); // Output: MicroUsbAdapter connects usb port with UsbCable
```

2. **Bridge**: Decouples an abstraction from its implementation so that the two can vary independently.

```typescript copy
interface Device { // Implementation
  isEnabled(): boolean;
  enable(): void;
  disable(): void;
}

class TV implements Device { // Concrete implementation
  private enabled = false;

  public isEnabled(): boolean {
    return this.enabled;
  }

  public enable(): void {
    this.enabled = true;
  }

  public disable(): void {
    this.enabled = false;
  }
}

class Remote { // Abstraction
  protected device: Device;

  constructor(device: Device) {
    this.device = device;
  }

  public togglePower(): void {
    if (this.device.isEnabled()) {
      this.device.disable();
    } else {
      this.device.enable();
    }
  }
}

const tv = new TV();
const remote = new Remote(tv);

remote.togglePower();
```

3. **Composite**: Composes objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

```typescript copy
interface Graphic {
  print(): void;
}

class CompositeGraphic implements Graphic {
  private children: Graphic[] = [];

  public add(child: Graphic): void {
    this.children.push(child);
  }

  public print(): void {
    this.children.forEach((child) => child.print());
  }
}

class Ellipse implements Graphic {
  public print(): void {
    console.log('Ellipse');
  }
}

class Rectangle implements Graphic {
  public print(): void {
    console.log('Rectangle');
  }
}

const ellipse = new Ellipse();
const rectangle = new Rectangle();

const graphic = new CompositeGraphic();
graphic.add(ellipse);
graphic.add(rectangle);

graphic.print();
```

4. **Decorator**: Dynamically adds new behavior to objects without altering their structure.

```typescript copy
interface Coffee {
  getCost(): number;
  getDescription(): string;
}

class SimpleCoffee implements Coffee {
  public getCost(): number {
    return 10;
  }

  public getDescription(): string {
    return 'Simple coffee';
  }
}

class MilkDecorator implements Coffee {
  private coffee: Coffee;

  constructor(coffee: Coffee) {
    this.coffee = coffee;
  }

  public getCost(): number {
    return this.coffee.getCost() + 2;
  }

  public getDescription(): string {
    return `${this.coffee.getDescription()}, milk`;
  }
}

const coffee: Coffee = new SimpleCoffee();
const milkCoffee: Coffee = new MilkDecorator(coffee);
console.log(coffee.getCost()); // Output: 12
console.log(coffee.getDescription()); // Output: Simple coffee, milk
```

5. **Facade**: Provides a simplified interface to a complex system.

```typescript copy
class Subsystem1 {
  public operation1(): string {
    return 'Subsystem1: Ready!';
  }
}

class Subsystem2 {
  public operation2(): string {
    return 'Subsystem2: Get ready!';
  }
}

class Facade {
  private subsystem1: Subsystem1;
  private subsystem2: Subsystem2;

  constructor(subsystem1: Subsystem1, subsystem2: Subsystem2) {
    this.subsystem1 = subsystem1;
    this.subsystem2 = subsystem2;
  }

  public operation(): string {
    let result = 'Facade initializes subsystems:\n';
    result += this.subsystem1.operation1();
    result += this.subsystem2.operation2();
    return result;
  }
}

const subsystem1 = new Subsystem1();
const subsystem2 = new Subsystem2();
const facade = new Facade(subsystem1, subsystem2);

facade.operation();
```